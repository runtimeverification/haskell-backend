# Booster backend

The booster backend is a re-write of the symbolic rewrite engine for K, also written in Haskell. The aims of this project are to build a symbolic execution engine which is faster and more easy to understand and debug than the current backend. To accomplish these goals, several trade-offs and restrictions were introduced into the design of the booster and in it's current state, the booster is not (yet) able to execute all the programs the old backend can. As a result, the booster backend falls back to the original backend, when it cannot proceed. This document serves as a high level overview of the architecture and the procedures inside the booster and should help the writer of a semantics in K, optimise their rules to take full advantage of the booster and the speedup and better explainability it offers.


## Booster architecture

The booster backend has been built from the ground up to be modular and tries to keep clear distinctions between various phases of symbolic execution. Unlike the old backend, which was originally built as a full CLI reachability prover, the booster backend is instead a JSON RPC server, which only exposes the basic building blocks of a symbolic execution engine via its API and leaves higher level functionality to the client. What this means is that the booster server is (mostly) stateless and only contains three main operations, namely:
 * execute
 * simplify
 * check implication / subsumption

The client can then build a prover based on this API by choosing how to store and explore the state-space, generated by calling the execute endpoint. This is useful, because different tools based on the same underlying re-writing engine might have different exploration strategies when execution branches, or might be interested in extracting different information from the state-space exploration. The small API allows the booster backend to focus on the core principles of symbolic execution, keeping the codebase much leaner and (hopefully) more understandable than the previous backend.

In the following sections we will go into details of the booster backend and will often refer to the booster aborting or falling back to the old backend during execution. This fallback is orchestrated by the `kore-rpc-booster` executable, which is internally referred to as the booster proxy. The booster proxy is a JSON RPC server that internally runs both a copy of the booster RPC server code as well as the old backend's RPC code. Whenever execution in booster aborts, the proxy intercepts the failure response and sends the configuration the booster returned to the old backend to be re-executed for one step. If the old backend is able to proceed and returns a re-written configuration, this is passed to the booster to resume execution.

This design was intentionally chosen to isolate the two code bases. Because the booster is a complete rewrite form the old backend, the internal representation of terms in both backends is completely different. The RPC interface and kore JSON serve as common interface, allowing the two backends to exchange data. As booster gets more powerful, it falls back to the old backend less and less and should eventually reach a point where it no longer needs to fall back, at which point the proxy can be removed entirely.


## Symbolic execution

Once the server is started with the rules for a given semantics, the execute end-point expects a configuration composed of a `Term`, representing the state of execution in a given semantics, along with boolean `Predicate`s/constraints imposed upon any symbolic parts of the state. Given this state, the server will apply semantic rules to the configuration, until either:

* no more rules apply
* a user specified break point is reached, based on a specific semantic rule or specified depth
* a branch occurs, i.e. more than one rule applies
* the booster cannot decide if a rule should apply

The execution can roughly be divided into two phases. The rewrite rule application phase and the simplification phase. Unlike the old backend, which is much more aggressive in applying simplification and function rules, the booster tries to apply rewrite rules as long as it can. Once it reaches a point where unification fails due to some part of the configuration containing un-evaluated functions which need to match a concrete value in the rule, the booster will run the simplifier on the current configuration to try to evaluate any function calls inside the configuration before trying to re-write again. This strategy avoids the costly simplifier running after each rewrite, but can be a double edged sword as the booster often ends up building a big stack of unevaluated functions in parts of the configuration. This usually happens in rules operating on the stack/heap/memory cells of a particular semantics, which often functionally update the state from previous configuration by calling an append/upsert/etc. function. In certain instances, the configuration ends up growing at an enormous rate as these thunks build up and can cause failure when the simplifier runs out of memory, trying to simplify such a huge configuration term. To prevent this from happening, the booster proxy contains a simple strategy which allows the user to force the simplification phase to be triggered every _n_ rewrite steps  (_n_ can be specified via a flag at server startup).

For an overview of what happens when an execute request is received, see the diagram bellow. We give further details of some of the steps/states in this diagram, in the following sections.

```
                                   Receive execute request   ──────────────────────────┐
                                                                                       │
                                             │                                         │
                                             ▼                                         ▼

                            Internalise KoreJSON into pattern P           Unsupported KoreJSON pattern

                                             │                                         │
                                             ▼                                         ▼

                                       Check P /= _|_                           Return an error

                                             │
                                             │   ┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
┌────────────────────────────────────────┐   │   │                                                                                                  │
│                                        ▼   ▼   ▼                                                                                                  │
│                                                                                                                                                   │
│         ┌────────────────────────────  Apply rule  ◄───────────────────────────────────────────────────────────────────────────────────────────┐  │
│         │                                                                                                                                      │  │
│         │                                    │                                                                                                 │  │
│         │                                    └─────────────┐                                                                                   │  │
│         ▼                                                  ▼                                                                                   │  │
│                                                                                                                                                │  │
│  Rewrite aborted            ┌────────────────────  Rewrite finished  ─────────────────────────┐                                                │  │
│                             │                                                                 │                                                │  │
│         │                   │                               │                                 │                                                │  │
│         │                   │                               │                                 │                                                │  │
│         ▼                   ▼                               ▼                                 ▼                                                │  │
│                                                                                                                                                │  │
│  Return aborted       No rules apply                 Rewrite to P'  ───┐                  Rewrite to PS ─────────────────┬───────┐             │  │
│                                                                        │                                                 │       │             │  │
│                             │                           │              │                    │      │                     │       │             │  │
│                             │                           │              │                    │      └──────────┐          │       │             │  │
│                             │                           ▼              ▼                    ▼                 ▼          │       ▼             │  │
│                             │                                                                                            │                     │  │
│                             │                         P' == _|_    P' /= _|_           /\ PS == _|_      PS simplify to  │   PS simplify to  ──┘  │
│                             │                                                                                   []       │      single P'         │
│              ┌──────────────┼─────────────┐               │           │ │                   │                            │                        │
│              │              │             │               │           │ │                   │                   │        │                        │
│              ▼              ▼             ▼               │           │ │                   │                   │        └───────┐                │
│                                                           │           │ │                   │                   │                ▼                │
│          Does not     Simplified      Simplifies          │  ┌────────┼─┼───────────────────┘                   │                                 │
│          simplify      already                            │  │        │ │                                       │          PS simplify to         │
│                                                           │  │        │ │                                       │                PS'              │
│              │              │             │               │  │        │ │                                       │                                 │
│              │              │             │               ▼  ▼        │ │                                       │                 │               │
│              │              │             │                           │ └─────────────────┐                     │                 ▼               │
│              │              │             │        Return vacuous P   │                   │                     │                                 │
│              │              │             │                           │                   │                     │         Return branching        │
│              │              │             │                           │                   │                     │                                 │
│              └───────┐      │             │                           ▼                   ▼                     │                                 │
│                      ▼      ▼             │                                                                     │                                 │
│                                           │                    Depth/rule bound       Unbounded  ───────────────┼─────────────────────────────────┘
│                     Return stuck P        │                                                                     │
│                                           │                           │                                         │
│                            ▲              │                           │                                         │
│                            │              │                           │                                         │
└────────────────────────────┼──────────────┘                           ▼                                         │
                             │                                                                                    │
                             │                                    Return simplified P'                            │
                             │                                                                                    │
                             │                                                                                    │
                             └────────────────────────────────────────────────────────────────────────────────────┘
```


### Internalisation from Kore JSON

When the execute endpoint receives a KoreJSON term (which is a JSON representation of a KORE term; see https://github.com/runtimeverification/haskell-backend/blob/master/docs/kore-syntax.md), we first try to internalise it into the internal `Term` type, together with a set of `Predicate`s. `Term` represents the configuration while each `Predicate` is a boolean constraint on some symbolic  part of the configuration (e.g. `X >Int 2` for some symbolic variable `X`). 

There are a few things to note in this step. Unlike the original backend, which is (roughly) an implementation of matching logic that KORE is based on (but does not strictly adhere to), the booster backend takes a simpler and more pragmatic approach to representing program configurations/predicates. As stated, the booster makes a strict distinction between the configuration state (i.e. data) and the boolean predicates/conditions over this state. As a result, the state is represented by the following simplified subset of KORE:

```haskell
data Term = 
    SymbolApplication Symbol [Sort] [Term]
  | DomainValue Sort String
  | Var Variable
  | Injection Sort Sort Term
```

_Note: In the actual codebase, there are some further internal data structures for more efficient handling of collections (maps, lists and sets). However, these can mostly be thought of as simply sugar notation for `SymbolApplication`s._

Boolean predicates of the configuration have the type `Predicate` and are simply `Term`s of sort `Bool`. When internalising, we go from a much richer/less constrained KORE language, containing various ML connectives such as `#Equals`, `#Ceil`, `#Exists`, etc. to the simplified `Term` language described above. As a result, not every KORE term is a "correct" configuration and there are times when the old backend produces KORE terms the booster is currently unable to process. This is usually the case with predicates, which are usually encoded in KORE as

```
{ true #Equal 1 >Int 0 }
```

whereas we simply store them as `1 >Int 0` in the booster (see [here](https://github.com/runtimeverification/hs-backend-booster/blob/bdc5d37d111d909302c31a725d938ae7ceb32fb2/library/Booster/Syntax/Json/Internalise.hs#L411-L535) for details of internalising predicates in the booster). 

_Note: The old backend works with predicates at the ML level and may return something which is a valid predicate, but the booster doesn't currently recognise. If this happens, the booster will emit a warning and treat the given predicate as an opaque term it isn't able to manipulate. This might cause issues later, if said predicate is needed to simplify some part of the configuration or prune a branch._

### Definedness check

Currently, we assume that every configuration `P` received by the server is defined, i.e. all partial functions inside the configuration are defined for the given inputs and it is therefore not `#Bottom`/`_|_`. It is currently up to the client to ensure that this condition holds and can be checked by sending a simplify request of `#Ceil(P)` to the old backend, which should return `#Top` if `P` is indeed defined. Definedness is a very important invariant for the booster and must be preserved throughout execution. Indeed the booster often aborts when the it cannot be sure if a rule/simplification preserves definedness and is therefore unable to proceed in applying said rule/ simplification safely. It instead falls back to the old backend, which has much more powerful, but slower mechanisms to deal with partiality.

### Rewriting

This step is at the core of the whole execute endpoint and is complex enough to warrant a separate diagram, describing what happens internally:

```
                                      Select a rule and try to
               ┌───────────────────     unify the LHS with P    ───────────────────────┐
               │                                                                       │
               │                                  │                                    │
               │                                  │                                    │
               │                                  │                                    │
               ▼                                  ▼                                    ▼

┌───── Unification fails             Unification succeeds with a   ──┐       Unfication uncertain  ─────┐
│                                       matching substitution        │                                  │
│                                                                    │                                  │
│                                        │      │  │                 └──►  Rule does not preserve       │
│                                        │      │  │                            definedness        ─┐   │
│           ┌────────────────────────────┘      │  └────────────────┐                               │   │
│           │                                   │                   │                               │   │
│           │                                   │                   │                               │   │
│           ▼                                   ▼                   ▼                               │   │
│                                                                                                   │   │
│  One of the requires     All requires clauses of the     Indeterminate requires   ────────────┐   │   │
│    clauses is False         rule evaluate to True             clause found                    │   │   │
│                                                                                               │   │   │
│           │                               │                                                   │   │   │
│           │                               ▼                                                   │   │   │
│           │                                                                                   │   │   │
│           │                           Add ensures clauses to the                              │   │   │
│           │                     ┌────     configuration and       ────┐                       │   │   │
│           │                     │       check for consitency          │                       │   │   │
│           │                     │                                     │                       │   │   │
│           │                     ▼                                     │                       │   │   │
│           │                                                           │                       │   │   │
│           │               Inconsistent                                │                       │   │   │
│           │              configuration                                │                       │   │   │
│           │                                                           │                       │   │   │
│           │                    │                                      │                       │   │   │
│           └───────────┐    ┌───┘                                      │                       │   │   │
│                       ▼    ▼                                          ▼                       ▼   ▼   ▼
│
└────────────────►  Fail current                                   Successful                Abort rewriting
                      rewrite                                        rewrite
```

The rule application procedure tries applying rules, grouped by priorities. If one or more rules from the current priority group apply, the rewritten configuration(s) get(s) returned. Otherwise, lower priority rules are tried until potentially all groups have been tried. If no rules applied, a stuck result is returned. 

The process of applying a single rule involves several stages. First, the unification procedure tries to match the LHS of a rewrite rule with the configuration. The unification procedure is more limited than in the old backend and a common source of failed unification is AC unification. Specifically, the booster can currently only perform unification of a small subset of restricted cases for maps, namely unifying concrete keys in the rule with concrete keys in the configuration. In practice, this covers a good portion of rewrite rules encountered in the real world. If unification fails with a complicated AC problem, it currently falls back onto the old backend.

If unification succeeds, the resulting substitution is checked to be a "matching" substitution, i.e. the variables of the substitution map are precisely only those that appear in the LHS of the rule. This substitution is then applied to the rule's RHS, which becomes the new configuration. Before a successful rewrite can be returned, the "requires" clauses/predicates of the rule have to be discharged. This means that all the predicates of the rule have to evaluate to true if the rule application is to be successful, or at least one evaluates to False if the rule does not apply. Predicate simplification proceeds in much the same way as the already mentioned configuration wide simplification step. However instead of applying function and simplification rules to the configuration, we instead call the simplifier on each of the *requires* clauses of the rule. If any of the predicates cannot be simplified to true/false, the booster proceeds to collect all such unknown predicates and uses an SMT solver to try to either derive a contradiction from the set of unknown predicates, in which case the rule application fails, or otherwise derive true. If the result is unknown again, the booster falls back onto the old backend.

If all the requires clauses have been successfully proven, the booster proceeds to check all the ensures clauses individually, in case any evaluate to false. It then calls the SMT solver again with the full set of current configuration constraints, also adding the new ensures clauses. If this new set of constraints is false/`_|_`, then the whole configuration is `_|_` and the booster records this rewrite as being trivial.

### Simplification / function evaluation

As mentioned in the previous section, the simplification code path is used at two different points of the execution, as well as being exported as a separate `simplify` JSON RPC endpoint. The simplification procedure underpinning all of these use-cases is largely the same and comprises of two main simplifiers, the concrete and symbolic one. Concrete function evaluation is handled by the LLVM backend and thus requires the semantics to be written in such a way, so as to be able to build both the kore definition used by the haskell backend, as well as the LLVM kore definition. The booster relies on the LLVM version of a semantics, compiled as a dynamic library, which is loaded when the server starts. During simplification, the term is traversed bottom up and any concrete sub-terms are sent to he LLVM backend to be evaluated.

The symbolic parts of a term are handled directly by the booster, which uses matching instead of unification to see whether an equation's RHS matches the current term. Similarly to rewrite rules, function rules may also have side conditions. As a result, the simplifier may have to recurse into evaluating whether the side-condition of a function/simplification rule evaluates to true/false before successfully rewriting the term. At the moment, the evaluation strategy and recursion limits for various stages of execution are hard-coded in the booster, as it is not clear if/when different recursion depth limits or top down vs bottom up simplification strategies might yield better results for different semantics.

### SMT constraint checking

As previously mentioned, when the booster cannot rewrite the value of a rule's "requires" clause to be true or false, it falls back to calling the SMT solver for said constraint. This SMT procedure encodes a limited subset of kore constructs directly into equivalent SMT functions (mostly arithmetic operations) and encodes everything else as uninterpreted SMT functions. Given the set of predicates `K` that hold in the current configuration and unknown "requires" condition `P` the SMT procedure checks whether `K => P` or `K => !P` (or neither of those implications holds). 

There is important caveat/limitation and a potential source of unsoundness stemming from the use of the SMT solver in both the booster and the old backend. When we translate certain functions, such as the `mod` or `/` function, in kore, these are partial functions undefined when the second argument is 0. However, Z3 (the SMT solver we use) does not understand partial function and instead treats all functions as total. This can lead to subtle and hard to find bugs (see https://github.com/runtimeverification/haskell-backend/issues/3603) and needs to be addressed in the future.

