Attributes as Patterns
======================

Background
----------

Attributes are used in Kore in order to provide hints for manipulating symbols,
axioms, sorts and so on.
When translating from K, the Kore attributes are a
fairly direct translation of the K ones.

Each Kore backend can have its own set of attributes, and backends must be able
to ignore unknown attributes.

Examples include the `constructor` attribute which
specifies that a certain symbol is a constructor, so, say, it
cannot be unified with different constructors.

Questions asked
---------------

1. What kind of structure do attributes have?
1. What syntax should we use?
1. How can we make sure that attributes have some documentation?

The answer to the first two questions comes from a Slack discussion on
`runtimeverification/#haskell`(https://runtimeverification.slack.com/messages/C9B9QBF46/) on 2018-17-25

* between @grosu, @bmmoore, @dwightguth, @u--, @njohnwalker, @traiansf, @hreada.
* Starting at: https://runtimeverification.slack.com/archives/C9B9QBF46/p1532543176000083
* Ending at: https://runtimeverification.slack.com/archives/C9B9QBF46/p1532562323000104

The answer to the third
comes from a face-to-face discussion between @traiansf and @virgil-serbanuta.

Attribute structure
-------------------

Attributes are identified by a name and might have (or not) parameters.

When present, attribute parameters are usually very simple, e.g. the `strict` attribute
can have a list of argument indexes in which it is strict.

Sometimes we may
want to refer to user-defined symbols, e.g. we may use the `unit` attribute
to specify the neutral element for an symbol, and we may want to use this
attribute both for the symbol declaration and for the axioms that
make it a neutral element.

Similarly, we may want to use an `refersTo`
attribute with a symbol as argument to, say,
link an associativity axiom with the symbol.

However, we can't tell what's the general structure of an attribute.

Attribute syntax
----------------

We could encode each attribute as a string (name/key) or as a pair of
strings (key-value).
However, that does not seem a natural way of encoding
the structure that they have, and each backend would need its own
string-parsing library.
Also, we may get some performance benefits since looking up a string key in a
map is slower than looking up a constant key from a finite and (likely)
very small set of such constants. However, note that the design of
backend-specific data structures for attributes may remove the need for
lookups.

We could also encode attributes as Kore patterns which must be fully correct.
This has some drawbacks:
* We would need a central definition of all attributes that might be used by
  backends, and all backends would need to be aware of this definition.
  This certainly has some benefits (e.g. one can find all the
  attributes and their documentation in a single place).
  As long as all attributes are generated by the frontend,
  this may be feasible, but having such a central repository would mean
  that independent backends cannot introduce their own attributes.
* Mentioning symbols and sorts in attributes becomes harder and unnatural.
  E.g. we wouldn't just be able to write `ac_axiom_for{}(plus{}())`, we would
  need to write either `ac_axiom_for{}(\dv(symbol{}("plus"))` which means that
  we partly give up on having structured data or
  `ac_axiom_for{}(plus{}(x:Int{},y:Int{}))`
  which would make it harder to manipulate these attributes.
* The syntax may be hard to read.
  This is not that important since K is meant to be readable, Kore is meant
  to be machine-readable.

Decision
--------

We will encode each attribute as a Kore pattern that uses only
application and string literals. This pattern will be an application
of a symbol to a list of parameters,
the (name of the) symbol identifying the
attribute and the list of parameters being the arguments of the attribute.
Numbers will be encoded as string literals.
Variables will appear as patterns with sort annotations.
Therefore the following may be valid attributes:
```
constructor{}()
strict{}("1", "2")
unit{}(epsilon{}())
unit{}(epsilon{}(), zero{}())
refersTo{}(plus{}())
concrete{}(VarI1:SortInt{},VarI2:SortInt{})
```
We will *not* check that this attributes are well-formed in the usual sense,
e.g. we will not check whether the `plus` symbol in the example above has
two arguments or that the `strict` symbol arguments are object patterns or have
the `#Pattern` sort.
We *will* check that the top-level element is an application pattern since we
must be able to find its name.
We *may* check that the pattern uses only application and string literals.
We *will* require a backend to provide a validation function for each attribute
it can understand.

Encouraging documentation
-------------------------

While we cannot make sure that people document their attributes, we will do
the following:

When indexing a definition (or maybe when parsing), a backend must
provide a collection of default attributes for each entity that can have
attributes (e.g. module, symbol, axiom).

A backend must also provide a map from attribute names to a structure which
contains:
* A function which adds the attribute to an existing collection of attributes.
* A plain text description of the attribute.
* A plain text description of the attribute syntax.
* A validation function. We may provide a way of representing a
hierarchical structure with documentation for each field, in which case the
plain-text syntax and part of the attribute documentation may be generated
automatically.

On the command line, we may add a flag which makes the verifier print all known
attributes with their documentation and syntax.

Attributes not present in this map will be wrapped in an opaque wrapper that,
in principle, can only be unwrapped by the unparsing code.
This parser will also be given to the function that adds attributes, in case
the backend wants to unparse them at some later point.

Attributes that do not pass validation will be provided in a list of
separate opaque wrappers, together with the error message provided by the
validator.

The indexed version of a Kore definition will only contain the backend's view of
the attributes.
