#+Title: JSON format to represent Kore terms

* Purpose and goals:
** exchange data between pyk, front-end, llvm-backend, hs-backend
  - a single format to exchange data between all components
  - scenario for the current (first) use case:
    1) HS backend server initialises
       - definitions are loaded (server state)
       - server is ready to use
    2) Pyk makes a request, e.g., "simplify: <kore-term>" or
       "run-rewrite: <kore-term>"
    3) HS backend responds with simplified/rewritten term
  - Pyk tracks all "current state" of the particular term,
    HS Backend state is only the general model loaded/kompiled
** Statements (from ticket)
- should be oriented on the textual kore format,
  https://github.com/runtimeverification/haskell-backend/blob/master/docs/kore-syntax.md
- should strive for "reusing code" (example: and/or representation as
  simple "connectives" rather than their own AST nodes)
- should not carry any artefacts for a particular component's purpose
  - *However*, how to convert from json to internal representations?
    There will be information missing that cannot be easily added.

* Approaches
1) use Haskell data types as-is, with From/ToJSON instances (maybe
   tweaked)
   - noisy if all data is kept
   - lossy if data is dropped in ToJSON (see below)
2) separate format/data types oriented on textual format
   - cannot construct attributes and (other) metadata present in HS
     backend only
     - What is that metadata? Can it be computed?

* Possible Work
** OBSOLETE hack in first version, instances on the existing types
*** DONE Starting in TermLikeF, notes as I go:
- can simply use deriving anyclass (ToJSON, FromJSON)
- instances can be customised using `genericToJSON/genericParseJSON`
  which take _Options_ to modify the encoding
- Id is a very basic type used in many others.
  - stores an ASTLocation. Should be omitted, supplying manual
    instance (following other instances, supplies AstLocationNone)
- _TermLikeF_ contains a few cases holding _InternalAc_ (Map, Set),
  whose JSON instances recurse to _Symbol_. Symbols have a list of
  attributes stored with them (e.g., whether this symbol is hooked to
  an internal implementation, whether it is a function, etc.).
  - these attributes cannot be reconstructed at all, nor should we
    expect anything to work without them.
  - Symbol-containing data cannot be represented in JSON.
  - *InternalAc stubbed out for the time being*
- Another complex case stepping out of Syntax: *Inj*, making use of
  _Symbol_ attributes (but only attributes) again. *Stubbed out*
- One case of _TermLikeF_ recurses into _TermLike VariableName_
  (ApplyAliasF), *stubbing out CofreeF*
  - which is actually quite besides the point! Better implement it
    properly.
  - TermLike = _CofreeF (TermLikeF v) (TermAttributes v) (TermLike v)_
    so it is recursively using _TermLike v_ for _child_ in _TermLikeF_
  - Attributes are less interesting, though, so _tailF_ to get the
    _TermLikeF v (TermLike v)_ out (and JSON-print it).

- another case using _Symbol_, ApplySymbolF, *stubbing out _Symbol_*

**** This approach was discarded as things become too entangled with internals
The CofreeF structure makes the encoding unsuitable for external consumption.
*** and a way to get a term out. Repl to dump the term as json
 - from repl/Main.hs
 - via Kore.Exec, and Kore.Repl
 - to Kore.Repl.Interpreter's _replInterpreter_ which
   - runs one command
   - mutating the interpreter state _ReplState_
 - inside Kore.Repl.Interpreter, we find that it operates on an _OrPattern_
   - which is a kind of _Pattern_
   - which is a _Conditional _ (TermLike VariableName)_
 - Meanwhile, after talking to Sam:
   - the json codec should replace a /parsing/ step in the Json-RPC server
   - parseKorePattern :: Text -> Parser ParsedPattern



** IN_PROGRESS model textual kore in Haskell data types (follow Ana's general model)
*** DONE Haskell data types to model a simple json format for textual kore
*** DONE write a Json schema along the textual core specification


*** write a conversion to/from internal types. "to" is probably incomplete
- Kore.Attribute.Attributes, Kore.Internal.Pattern
  #+BEGIN_EXAMPLE
  type ParsedPattern = Pattern VariableName Attribute.Null         -- Kore.Attribute.Attributes
  type Pattern variable = Conditional variable (TermLike variable) -- Kore.Internal.Pattern
  #+END_EXAMPLE
- a _Conditional v t_ (Kore.Internal.Conditional) has
  - term (:: t),
  - predicate (another Cofree thing) and substitutions working with v

*** implement a way to get a term out. As above, Repl, or (first) a round-trip test.
